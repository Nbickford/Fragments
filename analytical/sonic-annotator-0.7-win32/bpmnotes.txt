main.cpp ->
  qapplication.h
  qfont.h
  qstring.h
  qtextcodec.h
  qtranslator.h
  qmessagebox.h
  qiodevice.h
  qfile.h
  qstringlist.h
  stdio.h
  math.h
  
  mixxx.h
  soundsourceproxy.h
  qpixmap.h
  qsplashscreen.h
  errordialoghandler.h
  defs_version.h
  
  Calls MixxxApp (mixxx.h), then mixxx->show(), mixxx.exec()
  
mixxx.h, mixxx.cpp ->
  Classes: EngineMaster, 
           Library, 
		   LibraryScanner,
		   ControllerManager,
		   MixxxKeyboard,
		   PlayerManager,
		   RecordingManager,
		   SkinLoader,
		   VinylControlManager,
		   DlgPreferences,
		   SoundManager
	configobject.h
	util/cmdlineargs.h
	util/timer.h
	
	analyserqueue.h
	build.h //generated by SCons
	controlobjectthreadmain.h
	controlpotmeter.h
	defs_urls.h
	defs_version.h
	dlgabout.h
	dlgpreferences.h
	engine/enginemaster.h
	engine/enginemicrophone
	library/library.h
	library/libraryscanner.h
	library/librarytablemodel.h
	controllers/controllermanager.h
	mixxxkeyboard.h
	playermanager.h
	recording/defs_recording.h
	recording/recordingmanager.h
	skin/legacyskinparser.h
	skin/skinloader.h
	soundmanager.h
	soundmanagerutil.h
	soundsourceproxy.h
	trackinfoobject.h
	upgrade.h
	waveform/waveformwidgetfactory.h
	widget/wwaveformviewer.h
	widget/wwidget.h
	widget/wspinny.h
	sharedglcontext.h
	util/debug.h
	util/statsmanager.h
	util/timer.h
	
	check out slotFileLoadSongPlayer
	->slotLoadToDeck (in playermanager)
	
playermanager.h:
	configobject.h
	trackinfoobject.h
	
	Classes:
		ControlObject
		Deck
		Sampler
		PreviewDeck
		BaseTRackPlayer
		Library
		EngineMaster
		AnalyserQueue
		SoundManager
		VinylControlManager
		TrackCollection
	
	Includes:
	controlobject.h
	trackinfoobject.h
	deck.h
	sampler.h
	previewdeck.h
	analyserqueue.h
	controlobject.h
	samplerbank.h
	library/library.h
	library/trackcollection.h
	engine/enginemaster.h
	soundmanager.h
	vinylcontrol/vinylcontrolmaster.h
	util/stat.h
	
	slotLoadToDeck = slotLoadToPlayer(location,groupForDeck(deck-1))
	//the library will get the track and then signal back to us to load the
	//track via slotLoadTrackToPlayer
	=emit(loadLocationToPlayer(location,group))
	
	slotLoadTrackToPlayer(TrackPointer pTrack, QString group, bool play)
	BaseTrackPlayer.slotLoadTrack(pTrack,play)
	
	TrackPointer:
		in analyserbeats (11.5 kb)
		   analyserbpm (3.16)
		   analyserqueue (14.3)
		   analyserrg (3.23)
		   analyserwaveform (12.2)
		   baseeternalplaylistmodel (5.7)
		   baseexternaltrackmodel (4.2)
		   basesqltablemodel (29.4)
		   basetrackcache
		   etc
		   
AnalyserQueue:
	Includes:
		trackinfoobject
		playerinfo
		analyserqueue
		soundsourceproxy
		playerinfo
		util/timer
		library/trackcollection.h
		IF tonal: tonal/tonalanalyser.h
		analyserwaveform.h
		analyserbpm.h
		analyserrg.h
		IF vamp (true):
		analyserbeats.h
		vamp/vampanalyser.h
		70-140
		
		void run()
		doAnalysis
		
	opens a file pSoundSource
	iNumSamples=pSoundSource.length
	iSampleRate=pSoundSource.getSampleRate
	then doAnalysis(nextTrack,pSoundSource) - gives you analysis array
	then QListIterator<Analyser*> itf.finalize(nextTrack)
	then trackDone(nextTrack)
	
	doAnalysis:
		// TonalAnalyser requires a block size of 65536. Using a different value
		// breaks the tonal analyser. We need to use a smaller block size becuase on
		// Linux, the AnalyserQueue can starve the CPU of its resources, resulting
		// in xruns.. A block size of 8192 seems to do fine.
		const int ANALYSISBLOCKSIZE=8192
		totalSamples,processedSamples
		Read ANALYSISBLOCKSIZE samples into SAMPLE* data16
		//to compare apples to apples, ley's only look at blocks that are the full block size
		//If we get more samples than length only process up to the number we promised.
		samples[i]=data16[i]/32767.0f;
		Analyser* array - each one does process (samples, read).
		//Since this is a background analysis queue, we should yield every now and then.
		
Tonal Analyser (tonalanalyser.h):
		initialise(TrackInfoObject, sampleRate, totalSamples)
		process(CSAMPLE *pIn, const int iLen)
		finalize(TrackInfoObject* tio)
	includes:
		DiscontinuousSegmentation.hxx
		../segmentation.h
		../trackinfoobject.h
		analyser.h
		ChordExtractor.hxx
	
	m_ce() ->
	filterIntertia=0.7, 
	enableTunning=true, 
	enablePeakWindowing=true
	hopRatio=8.0
	segmentationMethod=1
	
	stereo->mono
	m_time=(iLen/2)/44100.0
	m_ce.doIt(mono,m_time)
	segmentation=m_ce.segmentation.dragOffset(segmentation.offsets().size()-1,m_time)
	
	analyser: process, cleanup, finalize (this is an object)
	
	OH
	
analyserbpm.cpp
	includes:
	trackinfoobject.h
	track/beatgrid.h
	track/beatfactory.h
	track/beatutils.h
	analyserbpm.h
	BPMDetect.h
	
    AnalyserBPM(ConfigObject<ConfigValue> *_config);
    bool initialise(TrackPointer tio, int sampleRate, int totalSamples);
    bool loadStored(TrackPointer tio) const;
    void process(const CSAMPLE *pIn, const int iLen);
    void cleanup(TrackPointer tio);
    void finalise(TrackPointer tio);
	
	m_pDetector (a ).inputSamples(pIn,iLen/2)
	configObjects, apparently 
	Where does BPMDetect.h come from?
	
	YES! It's from, um, lib\soundtouch.
	
	Where does Queen Mary come in?
	soundtouch\BPMDetect
	libsndfile
	taglib-1.9.1
	vamp-plugins\plugins OH WELL OBVIOUSLY DERP
	
	
sonic-annotator [-mr] -t trans.xml [...] -w <writer> [...] <audio> [...]
<audio>=audio file or URL

Forward slashes
local directory path + -r

vamp:qm-vamp-plugins:qm-tempotracker:beats OR
vamp:qm-vamp-plugins:qm-barbeattracker:beats